using UnityEngine;using System.Collections.Generic;using System;using System.Collections;using System.Linq;using UnityEditor.Animations;using UnityEngine.Events;using UnityEngine.EventSystems;public enum SMBcallback {Enter, Update, Exit}/// <summary> Interface used to send messages (using EzMsg or ExecuteEvents) to EzFSM </summary>public interface IFSM: IEventSystemHandler{    IEnumerable SetInteger(string parameter, int value);    IEnumerable SetFloat(string parameter, float value);    IEnumerable SetBool(string parameter, bool value);    IEnumerable SetTrigger(string value);    //void GetFSMState(ref EzFSM.StateData state);    FSMState GetCurrentState();}/// <summary>/// In tandem with BridgeSMB, EzFSM allows you to run UnityEvents at each animator state's/// callbacks (Enter/Stay/Exit), without the need to use AnimationClip hardcoded events/// </summary>public class EzFSM : MonoBehaviour, IFSM {    /// <summary> Animator layer to be used for the Logical FSM. Suggestion: 1, layer 0 used for actual animations </summary>    [HideInInspector]public int Layer = 1;    /// <summary> Should the current State Label gizmo show up? </summary>    [HideInInspector]public bool ShowLabel = true;    /// <summary> GUISkin to be applied to the Label </summary>    [HideInInspector]public GUISkin LabelGUISkin;    /// <summary> Label' offset from the gameObject's pivot </summary>    [HideInInspector]public Vector3 LabelOffset = new Vector3 (-10, 30, 0);    /// <summary> Show EzFSM Log in Unity Console (Slow, use for debug only)</summary>    [HideInInspector]public bool ShowLog;    /// <summary> Primary States list; Contains the stateHash, state name & UnityEvents </summary>    public List<FSMState> FSMStates = new List<FSMState>();    // This is what really matters. It' the Current State's Hash, convertible to state using the StatesData list    public FSMState CurrentState;    private AnimatorState[] _animatorStates;    private Animator _animator;    public Animator Animator {        get        {            if (_animator == null)                _animator = GetComponent<Animator>();            return _animator;        }    }    private AnimatorController _animatorController;    public AnimatorController AnimatorController {        get        {            if (_animatorController == null)                _animatorController = Animator.runtimeAnimatorController as AnimatorController;            return _animatorController;        }    }/// <summary>/// Updates all FSMStates in StatesData, pulling info from the Animator and AnimatorController/// </summary>    public void UpdateAnimatorStates() {        // Gets all states from currently selected layer        var layers = AnimatorController.layers;        var clipNames = new Dictionary<string, string>();        var childStates = layers[Layer].stateMachine.states;        foreach (var childState in childStates)        {            clipNames.Add(childState.state.name,childState.state.motion.name);//          Debug.Log(childState.state.name +" : "+childState.state.motion.name);        }        _animatorStates = Animator.GetStates();        FSMStates.Clear();        foreach (var animatorState in _animatorStates)        {            FSMStates.Add(FSMState.New(animatorState.name, animatorState.nameHash, clipNames[animatorState.name]));        }    }    void Awake() {        _animator = GetComponent<Animator>();    }    void Start () {        GetAnimatorState();        foreach (var state in FSMStates)        {            if (state!=null && state.OverrideClip!=null)                _animator.OverrideAnimationClip(state.ClipName, state.OverrideClip);        }    }		    void Update () {        if (CurrentState == null)            return;        CurrentState.OnUpdate.SafeInvoke();    }    void LateUpdate ()    {        if (CurrentState == null)            return;        CurrentState.OnUpdate.SafeInvoke();    }    void FixedUpdate ()    {        if (CurrentState == null)            return;        CurrentState.OnFixedUpdate.SafeInvoke();    }    /// <summary> This is called by BridgeSMB, attached to each subscribed state, to update the current state </summary>    public void StateMachineEvent(SMBcallback smbCallback, Animator animator, AnimatorStateInfo stateInfo, int layerIndex)    {        if (ShowLog)        {            var stateName = GetNameFromHash(stateInfo.shortNameHash);            Debug.Log(string.Format("SMB Callback :: {0} ~ {1}", smbCallback, stateName));        }        switch (smbCallback)        {            case SMBcallback.Enter:                GetFSMState(stateInfo.shortNameHash).OnEnter.SafeInvoke();                if (ShowLog) Debug.LogWarning("Entering State: " + GetFSMState(stateInfo.shortNameHash).Name);                break;            case SMBcallback.Update:                GetFSMState(stateInfo.shortNameHash).OnUpdate.SafeInvoke();                break;            case SMBcallback.Exit:                GetFSMState(stateInfo.shortNameHash).OnExit.SafeInvoke();                if (ShowLog) Debug.LogWarning("Exiting State: " + GetFSMState(stateInfo.shortNameHash).Name);                break;        }    }    private string GetNameFromHash(int shortNameHash)    {        // Returns the first element with the given NameHash (it should be just one, not checking)        FSMState FSMState = FSMStates.First(s => s.NameHash.Equals(shortNameHash));        if (FSMState != null)            return FSMState.Name;        return "";    }    /// <summary>Retrieves the StateData from the current state in the Animator. Should only be used on Start.</summary>    public FSMState GetAnimatorState()    {//            //TODO: Validate Layer Number            var animatorHash = _animator.GetCurrentAnimatorStateInfo(Layer).shortNameHash;            return GetFSMState(animatorHash);    }    /// <summary> Retrieves the StateData from the State (Hash) parameter </summary>    public FSMState GetFSMState(int animatorHash)    {//        # Returns the first element with the given NameHash (it should be just one, not checking)//        var currentNameHash = _animator.GetCurrentAnimatorStateInfo(Layer).shortNameHash;        //StateData stateData = StatesData.First(s => s.NameHash.Equals(currentNameHash));        foreach (var stateData in FSMStates)        {            if (stateData != null && stateData.NameHash == animatorHash)            {                CurrentState = stateData;                return stateData;            }        }//        Debug.LogError("state data match not found! Hash: "/*+ FSMState*/);        return null;    }    public IEnumerable SetInteger(string parameter, int i)    {        _animator.SetInteger(parameter, i);        yield break;    }    public IEnumerable SetFloat(string parameter, float f)    {        _animator.SetFloat(parameter, f);        yield break;    }    public IEnumerable SetBool(string parameter, bool b)    {        _animator.SetBool(parameter, b);        yield break;    }    public IEnumerable SetTrigger(string parameter)    {        _animator.SetTrigger(parameter);        yield break;    }    public FSMState GetCurrentState()    {        return CurrentState;    }//	public void AddState(int idx, StateData fsmActions) {//		StatesData.Add(idx, fsmActions);//		if (fsmActions.OnUpdate != null)//			_updateEvent += fsmActions.OnUpdate;//		if (fsmActions.OnFixedUpdate != null)//			_fixedUpdateEvent += fsmActions.OnFixedUpdate;//	}//	/// <summary> Internal. You should only switch states through the 'State' property change </summary>//	private bool SwitchState(int idx) {//		StateData act;//		var success = StatesData.TryGetValue(idx, out act);//		if (success) {//			StopEzFSMAction (_currentStateData);//			StartEzFSMAction (act);//		}//		return success;//	}	/// <summary> Runs the action and updates the current-Action pointer </summary>//	void StartEzFSMAction (StateData act) {//		if (act.OnEnter != null)//			act.OnEnter.Invoke ();//		if (act.OnUpdate != null)//			_updateEvent += act.OnUpdate;//		if (act.OnFixedUpdate != null)//			_fixedUpdateEvent += act.OnFixedUpdate;////		_currentStateData = act;//		CurrentStateName = act.Name;//	}////	void StopEzFSMAction (StateData act) {//		if (!_firstSwitch) {//			if (act.OnExit != null)//				act.OnExit ();//			if (act.OnUpdate != null)//				_updateEvent -= act.OnUpdate;//			if (act.OnFixedUpdate != null)//				_fixedUpdateEvent -= act.OnFixedUpdate;//		} else//			_firstSwitch = false;//	}//	//=====////	static void StaticConstructor() {//		UnityEditor.SceneView.onSceneGUIDelegate += OnScene;//	}//	static void OnScene(UnityEditor.SceneView sceneView) {//		GUI.Label(new Rect(10,10,10,10), "This is a label");//	}}